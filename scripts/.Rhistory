emmeans(chosenModel[[1]], pairwise ~ PMSScoreNew, adjust ="fdr", type="response")
}else{
emmeans(chosenModel[[1]], pairwise ~ PMSScoreNew*TestMoment, adjust ="fdr", type="response")
}
# tabel <- c()
#     for (i in 1:length(m)){
#   AIC<- AIC(m[[i]])
#   tabel <- c(tabel,round(AIC))}
# chosenModel<-m[which(tabel == min(tabel))]
# cat(sprintf("\nemmeans of formula: %s\n", Formula))
# if ((grepl("TestMoment", Formula)==FALSE)){
#  em<- emmeans(chosenModel[[1]], pairwise ~ PMSScoreNew, adjust ="fdr", type="response")
# }else{
#   em<-  emmeans(chosenModel[[1]], pairwise ~ PMSScoreNew*TestMoment, adjust ="fdr", type="response")
# }
#
})
output$emmeans <- renderPrint({
em()
})
}
shinyApp(ui=ui, server=server, options= list(height=800))
knitr::opts_chunk$set(dev = "png",
fig.path='Z:\\shares\\ghepmk_data\\2020_Kappen_PMS\\figures\\',
dpi = 300,
cache = FALSE)
library(Rmisc)
library(raincloudplots)
install.packages("raincloudplots")
library(lme4)
library(lmerTest)
library(effects)
library(dplyr)
library(car)
library(emmeans)
library(fitdistrplus)
library(gplots)
library(ggplot2)
library(ggstatsplot)
library(ggsignif)
library(ggformula)
library(ggdist)
library(ggpubr)
library(ggeffects)
library(gridExtra)
library(tidyverse)
library(pander)
library(stringr)
library(cowplot)
library(lavaan)
library(readr)
library(jpeg)
library(shiny)
library(reshape2)
library (yarrr)
library(knitr)
library(remotes)
install.packages("raincloudplots")
library(MASS)
library(reshape2)
# define covariance matrix of v1-v10 in class 1
# diagonal: variances of v1-v10
# off-diagonal: covariances between v1-v10
Sigma1 <- rbind(c(1.0,0.0,0.2,0.1,0.1,0.3,0.1,0.2,0.1,0.1),
c(0.0,1.1,0.1,0.2,0.1,0.2,0.2,0.3,0.2,0.1),
c(0.2,0.1,1.0,0.1,0.2,0.1,0.1,0.2,0.1,0.2),
c(0.1,0.2,0.1,2.0,0.2,0.1,0.2,0.1,0.2,0.1),
c(0.1,0.1,0.2,0.2,2.8,0.2,0.1,0.1,0.2,0.1),
c(0.3,0.2,0.1,0.1,0.2,1.0,0.3,0.2,0.0,0.1),
c(0.1,0.2,0.1,0.2,0.1,0.3,2.0,0.1,0.2,0.1),
c(0.2,0.3,0.2,0.1,0.1,0.2,0.1,1.0,0.2,0.1),
c(0.1,0.2,0.1,0.2,0.2,0.0,0.2,0.2,1.0,0.2),
c(0.1,0.1,0.2,0.1,0.1,0.1,0.1,0.1,0.2,1.0))
# simulate class 1 responses (v1-v10), based on means (mu)
17
# simulate class 1 responses (v1-v10), based on means (mu)
# and covariance matrix (sigma)
set.seed(0111)
cl1 <-mvrnorm(100, mu=c(2,3,2,6,7,4,5,8,2,1), Sigma=Sigma1)
#########################################################
####### define covariance matrix of v1-v10 in class 2 ###
Sigma2 <- rbind(c(2.0,0.1,0.2,0.1,0.1,0.3,0.1,0.2,0.1,0.1),
c(0.1,1.5,0.1,0.2,0.1,0.1,0.2,0.3,0.2,0.1),
c(0.2,0.1,1.0,0.1,0.2,0.1,0.1,0.2,0.1,0.2),
c(0.1,0.2,0.1,1.5,0.2,0.1,0.2,0.1,0.2,0.1),
c(0.1,0.1,0.2,0.2,1.0,0.2,0.1,0.1,0.2,0.1),
c(0.3,0.1,0.1,0.1,0.2,2.0,0.3,0.2,0.0,0.1),
c(0.1,0.2,0.1,0.2,0.1,0.3,1.0,0.1,0.2,0.1),
c(0.2,0.3,0.2,0.1,0.1,0.2,0.1,2.0,0.2,0.1),
c(0.1,0.2,0.1,0.2,0.2,0.0,0.2,0.2,1.0,0.2),
c(0.1,0.1,0.2,0.1,0.1,0.1,0.1,0.1,0.2,1.5))
# simulate class 2 responses (v1-v10), based on means (mu)
# and covariance matrix (sigma)
set.seed(0111)
cl2 <-mvrnorm(110, mu=c(6,7,1,3,2,8,3,8,2,5), Sigma=Sigma2)
##########################################################
######## define covariance matrix of v1-v10 in class 3 ###
Sigma3 <- rbind(c(1.0,0.1,0.2,0.1,0.1,0.3,0.1,0.3,0.1,0.1),
c(0.1,1.0,0.1,0.2,0.1,0.1,0.2,0.3,0.2,0.1),
c(0.2,0.1,2.2,0.1,0.2,0.1,0.1,0.2,0.1,0.2),
c(0.1,0.2,0.1,2.0,0.1,0.1,0.2,0.1,0.2,0.1),
c(0.1,0.1,0.2,0.1,1.0,0.2,0.1,0.1,0.2,0.1),
c(0.3,0.1,0.1,0.1,0.2,1.0,0.3,0.2,0.0,0.1),
c(0.1,0.2,0.1,0.2,0.1,0.3,1.0,0.1,0.2,0.1),
c(0.3,0.3,0.2,0.1,0.1,0.2,0.1,1.2,0.2,0.1),
c(0.1,0.2,0.1,0.2,0.2,0.0,0.2,0.2,3.0,0.2),
c(0.1,0.1,0.2,0.1,0.1,0.1,0.1,0.1,0.2,2.0))
# simulate class 3 responses (v1-v10), based on means (mu)
# and covariance matrix (sigma)
set.seed(0111)
cl3 <-mvrnorm(90, mu=c(2,5,8,7,5,2,1,4,9,8), Sigma=Sigma3)
##########################################################
### convert matrices to data.frame objects & add a class nr
cl1 <- as.data.frame(cl1)
cl1$class <-rep(1,100)
cl2 <- as.data.frame(cl2)
cl2$class <-rep(2,110)
cl3 <- as.data.frame(cl3)
cl3$class <- rep(3,90)
View(cl3)
# merge the three class dataframes and add ID numbers
dat1 <- rbind(cl1,cl2,cl3)
colnames(dat1) <- c('var1', 'var2', 'var3', 'var4', 'var5',
'var6', 'var7', 'var8', 'var9', 'var10',
'class')
dat1$class <- as.factor(dat1$class)
View(dat1)
dat1$id <- seq(1,300,1)
##########################################################
### add a little stochastic noise for increased realism ;)
dat1$var1 <- dat1$var1 + rnorm(n=300, mean=0, sd=sqrt(1))
dat1$var2 <- dat1$var2 + rnorm(n=300, mean=0, sd=sqrt(1))
dat1$var3 <- dat1$var3 + rnorm(n=300, mean=0, sd=sqrt(1))
dat1$var4 <- dat1$var4 + rnorm(n=300, mean=0, sd=sqrt(1))
dat1$var5 <- dat1$var5 + rnorm(n=300, mean=0, sd=sqrt(1))
dat1$var6 <- dat1$var6 + rnorm(n=300, mean=0, sd=sqrt(1))
dat1$var7 <- dat1$var7 + rnorm(n=300, mean=0, sd=sqrt(1))
dat1$var8 <- dat1$var8 + rnorm(n=300, mean=0, sd=sqrt(1))
dat1$var9 <- dat1$var9 + rnorm(n=300, mean=0, sd=sqrt(1))
dat1$var10 <- dat1$var10 + rnorm(n=300, mean=0, sd=sqrt(1))
# Visualize real quick
ggplot(data, aes(group=id, color=class)) +
geom_line()
# Visualize real quick
library(ggplot2)
ggplot(data, aes(group=id, color=class)) +
geom_line()
ggplot(dat1, aes(group=id, color=class)) +
geom_line()
library(babynames)
# Get to long format
dat2 <- reshape(dat1, direction='long', # Transform dataframe to long format
varying=list(c("var1", "var2", "var3", "var4", "var5", "var6", "var7", "var8", "var9", "var10")),
timevar='variables',
times=c("var1", "var2", "var3", "var4", "var5", "var6", "var7", "var8", "var9", "var10"),
idvar= c('id'))
View(dat2)
# Get to long format
dat2 <- reshape(dat1, direction='long', # Transform dataframe to long format
varying=list(c("var1", "var2", "var3", "var4", "var5", "var6", "var7", "var8", "var9", "var10")),
timevar='variables',
times=c("var1", "var2", "var3", "var4", "var5", "var6", "var7", "var8", "var9", "var10"),
v.names=c('Value'),
idvar= c('id'))
# Visualize real quick
library(ggplot2)
ggplot(dat2, aes(x = variables, y = Value, group=id, color=class)) +
geom_line()
########### MClust ####
library(mclust)
install.packages("mclust")
mnames <- c("EEI", "EEE", "VVI", "VVV")
# Fit 1-5 class model
mod_g1_9 <- Mclust(dat1[, 1:10], modelNames = mnames)
########### MClust ####
library(mclust)
# Fit 1-5 class model
mod_g1_9 <- Mclust(dat1[, 1:10], modelNames = mnames)
View(mod_g1_9)
# Opimal number of classes
mod_g1_9$G
# Optimal model variant
mod_g1_9$modelName
# Check all model's / class numbers BIC's
mod_g1_9$BIC
mod_g1_9$loglik
mod_g1_9$df
BIC = 2(−5951.275) − 42(log(300)) = −12142.11
BIC = 2(-5951.275) - 42(log(300))
BIC = 2*(-5951.275) - 42(log(300))
42(log(300))
42*(log(300))
BIC = 2*(-5951.275) - 42*(log(300))
BIC
# tabulate class-membership numbers
table(summary(mod_g1_9)$classification)
# display the means per class
mod_g1_9$parameters$mean
# select the first of 3 10-by-10 variance matrices
mod_g1_9$parameters$variance$sigma[1:10, 1:10, 1]
mod_g1_9$z
# mod_g1_9$z # Each subjects probability to be part of a certain estimated class
mod_g1_9$classification
mod_g1_9$uncertainty
# Check max and mean uncertainty over all participants
max(mod_g1_9$uncertainty)
mean(mod_g1_9$uncertainty)
# Plot or tabulate uncertainty per class to gain further insight
cprob <- cbind(mod_g1_9$z, mod_g1_9$classification)
cprob <- as.data.frame(cprob)
colnames(cprob) <- c("prob (class 1)", "prob (class 2)", "prob (class 3)", "class")
aggregate(cprob[, 1:3], list(cprob$class), mean)
install.packages("tidyLPA")
# Predict LPA models with 1-9 classes, with an EI config:
suppressMessages(library(tidyLPA))
suppressMessages(mod_1c_v1 <- estimate_profiles(df = dat1[1:10], n_profiles = 1:9,
models = 1))
mod_1c_v1
# Optimal model variant
mod_g1_9$modelName
# Opimal number of classes
mod_g1_9$G
# Optimal model variant
mod_g1_9$modelName
# Check all model's / class numbers BIC's
mod_g1_9$BIC # Maybe weird that negative, but: BIC = 2(Loglikelihood) − df(log(n))
mod_g1_9$loglik
mod_g1_9$df
BIC = 2*(-5951.275) - 42*(log(300)) # See?, same BIC!
# tabulate class-membership numbers
table(summary(mod_g1_9)$classification)
# display the means per class
mod_g1_9$parameters$mean
# select the first of 3 10-by-10 variance matrices
mod_g1_9$parameters$variance$sigma[1:10, 1:10, 1]
# mod_g1_9$z # Each subjects probability to be part of a certain estimated class
mod_g1_9$classification # Leading to a class classification matrix; posterior allocation
mod_g1_9$uncertainty # WATCH OUT, only use classification if it is a clear cut case which class a participant belongs to. Else; use uncertainty indices.
suppressMessages(mod_1c_v2 <- estimate_profiles(df = dat1[1:10], n_profiles = 1:9,
models = c(1,2,3,6)))
# Let's try to fix all variable covariances to zero
mod_1c_v2 <- estimate_profiles(df = dat1[1:10], n_profiles = 1:9, variances = "equal",
covariances = "zero")
mod_1c_v2$model_1_class_2$fit
# Compare model fits (for v1)
comp <- suppressWarnings(compare_solutions(mod_1c_v1))
comp$fits
comp$best
##############################
#                            #
#     All Analysis   V1      #
#    Audio and Physiology    #
#       Cyberball-MIST       #
#                            #
#############################
#
# Author: Mitchel Kappen
# 15-6-2022
library(arrow) # Parquets
library(lme4)
library(car)
library(emmeans)
library(ggplot2)
library(dplyr)
##### Set environment #####
rm(list = ls()) # Clear environment
cat("\014") # Clear console
dev.off() # Clear plot window
# Set and Get directories
setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) #Set WD to script location
source("functions.R") # Load document where functions are stored
nAGQ = 1
plotPrefix <- "../figures/"
##### Loading data #####
# Audio Data
audioData <-
as.data.frame(read_parquet("../loc_data/df_gemaps_func.parquet"))
# Limesurvey Data
questionData <- as.data.frame(read.csv("../loc_data/QuestionnaireResults.csv"))
questionData$participantNum = questionData$Participant.Number # Change name for merge
colnames(questionData)[which(names(questionData) == "DASS.SCORES")] <- "DASS.Depression"
colnames(questionData)[which(names(questionData) == "X")] <- "DASS.Anxiety"
colnames(questionData)[which(names(questionData) == "X.1")] <- "DASS.Stress"
colnames(questionData)[which(names(questionData) == "RRS.SCORES")] <- "RRS.SCORE"
colnames(questionData)[which(names(questionData) == "X.2")] <- "RRS.Reflection"
colnames(questionData)[which(names(questionData) == "X.3")] <- "RRS.Brooding"
audioData = merge(audioData, questionData, by = "participantNum") # Merge audioData with trait questionnaires
# Behavioral Data
behavioralData <-
as.data.frame(read_parquet("../loc_data/behavioralData_CYBB_MIST.parquet"))
behavioralData$participantNum = behavioralData$participant_ID # Change name for merge
behavioralData <- behavioralData[c("participantNum", # Create smaller dataframe with only relevant variables
"Mean_SCRS_Baseline", "Mean_SCRS_Control", "Mean_SCRS_Stress",
"Mean_VAS_NA_Baseline", "Mean_VAS_PAA_Baseline", "Mean_VAS_PSA_Baseline", "VAS_Stress_Baseline",
"Mean_VAS_NA_Control_Post_Rest", "Mean_VAS_PAA_Control_Post_Rest", "Mean_VAS_PSA_Control_Post_Rest", "VAS_Stress_Control_Post_Rest",
"Mean_VAS_NA_Control", "Mean_VAS_PAA_Control", "Mean_VAS_PSA_Control", "VAS_Stress_Control",
"Mean_VAS_NA_Stress_Post_Rest", "Mean_VAS_PAA_Stress_Post_Rest", "Mean_VAS_PSA_Stress_Post_Rest", "VAS_Stress_Stress_Post_Rest",
"Mean_VAS_NA_Stress", "Mean_VAS_PAA_Stress", "Mean_VAS_PSA_Stress", "VAS_Stress_Stress",
"taskType")]
behavioralDataLong <- reshape(behavioralData, direction='long', # Transform dataframe to long format
varying=list(c("Mean_VAS_NA_Baseline", "Mean_VAS_NA_Control_Post_Rest", "Mean_VAS_NA_Control", "Mean_VAS_NA_Stress_Post_Rest", "Mean_VAS_NA_Stress"),
c("Mean_VAS_PAA_Baseline", "Mean_VAS_PAA_Control_Post_Rest", "Mean_VAS_PAA_Control", "Mean_VAS_PAA_Stress_Post_Rest", "Mean_VAS_PAA_Stress"),
c("Mean_VAS_PSA_Baseline", "Mean_VAS_PSA_Control_Post_Rest", "Mean_VAS_PSA_Control", "Mean_VAS_PSA_Stress_Post_Rest", "Mean_VAS_PSA_Stress"),
c("VAS_Stress_Baseline", "VAS_Stress_Control_Post_Rest", "VAS_Stress_Control", "VAS_Stress_Stress_Post_Rest", "VAS_Stress_Stress")),
timevar='fileNum',
times=c('baseline', 'control rest', 'control', 'stress rest', 'stress'),
v.names=c('VAS_NA', 'VAS_PAA', 'VAS_PSA', 'VAS_Stress'),
idvar= c('participantNum', 'taskType'))
# This is easier to work with to plot over time and needed to merge with behavioralData
audioData$fileNum[audioData$fileName == "audio_picture_baseline.wav"] = "baseline"
audioData$fileNum[audioData$fileName == "audio_referential_control.wav"] = "control"
audioData$fileNum[audioData$fileName == "audio_picture_control.wav"] = "control rest"
audioData$fileNum[audioData$fileName == "audio_referential_stress.wav"] = "stress"
audioData$fileNum[audioData$fileName == "audio_picture_stress.wav"] = "stress rest"
audioData = merge(audioData, behavioralDataLong, by = c("participantNum","taskType", "fileNum"))
audioData$paradigm[grepl("referential", audioData$fileName)] = "Referential"
audioData$paradigm[grepl("picture", audioData$fileName)] = "Pic Describe"
audioData <- audioData %>% # Factorize relevant variables
transform(participantNum = as.factor(participantNum),
taskType = as.factor(taskType),
descriptionType = as.factor(descriptionType),
experimentPhase = as.factor(experimentPhase),
Sex = as.factor(Sex),
Age = as.double(Age),
paradigm = as.factor(paradigm),
DASS.Depression = as.double(DASS.Depression),
DASS.Anxiety = as.double(DASS.Anxiety),
DASS.Stress = as.double(DASS.Stress),
RRS.SCORE = as.double(RRS.SCORE),
RRS.Reflection = as.double(RRS.Reflection),
RRS.Brooding = as.double(RRS.Brooding))
audioData$fileNum <- ordered(audioData$fileNum, levels = c('baseline', 'control', 'control rest', 'stress', 'stress rest')) # Factorize (ordered) moment
levels(audioData$fileNum) <- list("Baseline"  = "baseline", "Control Task" = "control", "Control Rest" = "control rest", "Stress Task" = "stress", "Stress Rest" = "stress rest")
levels(audioData$taskType) <- list(Cyberball = "cybb", MIST = "mist")
# Create a dataframe omitting all other time moments
audioData = filter(audioData, fileNum == "Control Task" | fileNum == "Stress Task")
# Physiological Data (couldn't do that earlier, because different time moments)
physiologicalData <- as.data.frame(read_parquet("../loc_data/df_feat_tot.parquet"))
physiologicalData$taskType[physiologicalData$condition == "mist"] = "MIST"
physiologicalData$taskType[physiologicalData$condition == "cybb"] = "Cyberball"
physiologicalData$participantNum = physiologicalData$patient_id
physiologicalData$fileNum[physiologicalData$trigger == "Start MIST control"] = "Control Task"
physiologicalData$fileNum[physiologicalData$trigger == "Start MIST stress"] = "Stress Task"
physiologicalData$fileNum[physiologicalData$trigger == "Start cyberball control"] = "Control Task"
physiologicalData$fileNum[physiologicalData$trigger == "Start cyberball stress"] = "Stress Task"
physiologicalData <- physiologicalData[c("participantNum", "taskType", "fileNum", "duration_s", "rmssd", "sdnn",
"mean_hr", "max_hr", "min_hr", "std_hr", "lf", "hf", "lf_hf_ratio", "total_power",
"SCRR", "phasic_area", "tonic_mean", "phasic_area_normalized", "mean_EDA_SQI")]
physiologicalData = filter(physiologicalData, fileNum == "Control Task" | fileNum == "Stress Task")
#  Present in physiological, but not in rest
physiologicalData$participantNum[!physiologicalData$participantNum %in% audioData$participantNum]
# Present in rest, but not in physiological
audioData$participantNum[!audioData$participantNum %in% physiologicalData$participantNum]
# Merge to final dataframe
allData = merge(audioData, physiologicalData, by = c("participantNum","taskType", "fileNum"))
summary(allData)
####### Speech features #######
# Speech features: F0 ######
formula <- 'F0semitoneFrom27.5Hz_sma3nz_amean ~ fileNum * taskType + Sex + (1|participantNum)' # Declare formula
datatemp <- audioData[c('F0semitoneFrom27.5Hz_sma3nz_amean', 'fileNum', 'taskType', 'Sex', 'paradigm', 'participantNum')] # Clean dataframe to check with Jens
dataModel = allData # Ensure correct data is taken
rm(d0.1, d0.2, d0.3) # Just to be sure you're not comparing former models for this comparison
d0.1 <- lmer(formula,data=dataModel)
d0.2 <- glmer(formula,data=dataModel, family = Gamma(link = "identity"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ = nAGQ)
d0.3 <- glmer(formula,data=dataModel, family = inverse.gaussian(link = "identity"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ = nAGQ)
# Model Selection
modelNames = c(d0.1,d0.2,d0.3)
tabel <- cbind(AIC(d0.1), AIC(d0.2), AIC(d0.3))
chosenModel = modelNames[which(tabel == min(tabel))] # Get model with lowest AIC
Anova(chosenModel[[1]], type = 'III')
plot(effect("fileNum:taskType", chosenModel[[1]]))
emmeans0.1 <- emmeans(chosenModel[[1]], pairwise ~ fileNum | taskType, adjust ="fdr", type = "response") #we don't adjust because we do this later
emmeans0.2 <- emmeans(chosenModel[[1]], pairwise ~ taskType | fileNum, adjust ="fdr", type = "response") #we don't adjust because we do this later
emm0.1 <- summary(emmeans0.1)$emmeans
emmeans0.1$contrasts
##############################
#                            #
#     All Analysis   V1      #
#    Audio and Physiology    #
#       Cyberball-MIST       #
#                            #
#############################
#
# Author: Mitchel Kappen
# 15-6-2022
library(arrow) # Parquets
library(lme4)
library(car)
library(emmeans)
library(ggplot2)
library(dplyr)
##### Set environment #####
rm(list = ls()) # Clear environment
cat("\014") # Clear console
dev.off() # Clear plot window
# Set and Get directories
setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) #Set WD to script location
source("functions.R") # Load document where functions are stored
nAGQ = 1
plotPrefix <- "../figures/"
##### Loading data #####
# Audio Data
audioData <-
as.data.frame(read_parquet("../loc_data/df_gemaps_func.parquet"))
# Limesurvey Data
questionData <- as.data.frame(read.csv("../loc_data/QuestionnaireResults.csv"))
questionData$participantNum = questionData$Participant.Number # Change name for merge
colnames(questionData)[which(names(questionData) == "DASS.SCORES")] <- "DASS.Depression"
colnames(questionData)[which(names(questionData) == "X")] <- "DASS.Anxiety"
colnames(questionData)[which(names(questionData) == "X.1")] <- "DASS.Stress"
colnames(questionData)[which(names(questionData) == "RRS.SCORES")] <- "RRS.SCORE"
colnames(questionData)[which(names(questionData) == "X.2")] <- "RRS.Reflection"
colnames(questionData)[which(names(questionData) == "X.3")] <- "RRS.Brooding"
audioData = merge(audioData, questionData, by = "participantNum") # Merge audioData with trait questionnaires
# Behavioral Data
behavioralData <-
as.data.frame(read_parquet("../loc_data/behavioralData_CYBB_MIST.parquet"))
behavioralData$participantNum = behavioralData$participant_ID # Change name for merge
behavioralData <- behavioralData[c("participantNum", # Create smaller dataframe with only relevant variables
"Mean_SCRS_Baseline", "Mean_SCRS_Control", "Mean_SCRS_Stress",
"Mean_VAS_NA_Baseline", "Mean_VAS_PAA_Baseline", "Mean_VAS_PSA_Baseline", "VAS_Stress_Baseline",
"Mean_VAS_NA_Control_Post_Rest", "Mean_VAS_PAA_Control_Post_Rest", "Mean_VAS_PSA_Control_Post_Rest", "VAS_Stress_Control_Post_Rest",
"Mean_VAS_NA_Control", "Mean_VAS_PAA_Control", "Mean_VAS_PSA_Control", "VAS_Stress_Control",
"Mean_VAS_NA_Stress_Post_Rest", "Mean_VAS_PAA_Stress_Post_Rest", "Mean_VAS_PSA_Stress_Post_Rest", "VAS_Stress_Stress_Post_Rest",
"Mean_VAS_NA_Stress", "Mean_VAS_PAA_Stress", "Mean_VAS_PSA_Stress", "VAS_Stress_Stress",
"taskType")]
behavioralDataLong <- reshape(behavioralData, direction='long', # Transform dataframe to long format
varying=list(c("Mean_VAS_NA_Baseline", "Mean_VAS_NA_Control_Post_Rest", "Mean_VAS_NA_Control", "Mean_VAS_NA_Stress_Post_Rest", "Mean_VAS_NA_Stress"),
c("Mean_VAS_PAA_Baseline", "Mean_VAS_PAA_Control_Post_Rest", "Mean_VAS_PAA_Control", "Mean_VAS_PAA_Stress_Post_Rest", "Mean_VAS_PAA_Stress"),
c("Mean_VAS_PSA_Baseline", "Mean_VAS_PSA_Control_Post_Rest", "Mean_VAS_PSA_Control", "Mean_VAS_PSA_Stress_Post_Rest", "Mean_VAS_PSA_Stress"),
c("VAS_Stress_Baseline", "VAS_Stress_Control_Post_Rest", "VAS_Stress_Control", "VAS_Stress_Stress_Post_Rest", "VAS_Stress_Stress")),
timevar='fileNum',
times=c('baseline', 'control rest', 'control', 'stress rest', 'stress'),
v.names=c('VAS_NA', 'VAS_PAA', 'VAS_PSA', 'VAS_Stress'),
idvar= c('participantNum', 'taskType'))
# This is easier to work with to plot over time and needed to merge with behavioralData
audioData$fileNum[audioData$fileName == "audio_picture_baseline.wav"] = "baseline"
audioData$fileNum[audioData$fileName == "audio_referential_control.wav"] = "control"
audioData$fileNum[audioData$fileName == "audio_picture_control.wav"] = "control rest"
audioData$fileNum[audioData$fileName == "audio_referential_stress.wav"] = "stress"
audioData$fileNum[audioData$fileName == "audio_picture_stress.wav"] = "stress rest"
audioData = merge(audioData, behavioralDataLong, by = c("participantNum","taskType", "fileNum"))
audioData$paradigm[grepl("referential", audioData$fileName)] = "Referential"
audioData$paradigm[grepl("picture", audioData$fileName)] = "Pic Describe"
audioData <- audioData %>% # Factorize relevant variables
transform(participantNum = as.factor(participantNum),
taskType = as.factor(taskType),
descriptionType = as.factor(descriptionType),
experimentPhase = as.factor(experimentPhase),
Sex = as.factor(Sex),
Age = as.double(Age),
paradigm = as.factor(paradigm),
DASS.Depression = as.double(DASS.Depression),
DASS.Anxiety = as.double(DASS.Anxiety),
DASS.Stress = as.double(DASS.Stress),
RRS.SCORE = as.double(RRS.SCORE),
RRS.Reflection = as.double(RRS.Reflection),
RRS.Brooding = as.double(RRS.Brooding))
audioData$fileNum <- ordered(audioData$fileNum, levels = c('baseline', 'control', 'control rest', 'stress', 'stress rest')) # Factorize (ordered) moment
levels(audioData$fileNum) <- list("Baseline"  = "baseline", "Control Task" = "control", "Control Rest" = "control rest", "Stress Task" = "stress", "Stress Rest" = "stress rest")
levels(audioData$taskType) <- list(Cyberball = "cybb", MIST = "mist")
# Create a dataframe omitting all other time moments
audioData = filter(audioData, fileNum == "Control Task" | fileNum == "Stress Task")
# Physiological Data (couldn't do that earlier, because different time moments)
physiologicalData <- as.data.frame(read_parquet("../loc_data/df_feat_tot.parquet"))
physiologicalData$taskType[physiologicalData$condition == "mist"] = "MIST"
physiologicalData$taskType[physiologicalData$condition == "cybb"] = "Cyberball"
physiologicalData$participantNum = physiologicalData$patient_id
physiologicalData$fileNum[physiologicalData$trigger == "Start MIST control"] = "Control Task"
physiologicalData$fileNum[physiologicalData$trigger == "Start MIST stress"] = "Stress Task"
physiologicalData$fileNum[physiologicalData$trigger == "Start cyberball control"] = "Control Task"
physiologicalData$fileNum[physiologicalData$trigger == "Start cyberball stress"] = "Stress Task"
physiologicalData <- physiologicalData[c("participantNum", "taskType", "fileNum", "duration_s", "rmssd", "sdnn",
"mean_hr", "max_hr", "min_hr", "std_hr", "lf", "hf", "lf_hf_ratio", "total_power",
"SCRR", "phasic_area", "tonic_mean", "phasic_area_normalized", "mean_EDA_SQI")]
physiologicalData = filter(physiologicalData, fileNum == "Control Task" | fileNum == "Stress Task")
#  Present in physiological, but not in rest
physiologicalData$participantNum[!physiologicalData$participantNum %in% audioData$participantNum]
# Present in rest, but not in physiological
audioData$participantNum[!audioData$participantNum %in% physiologicalData$participantNum]
# Merge to final dataframe
allData = merge(audioData, physiologicalData, by = c("participantNum","taskType", "fileNum"))
summary(allData)
####### Speech features #######
# Speech features: F0 ######
formula <- 'F0semitoneFrom27.5Hz_sma3nz_amean ~ fileNum * taskType + Sex + (1|participantNum)' # Declare formula
datatemp <- audioData[c('F0semitoneFrom27.5Hz_sma3nz_amean', 'fileNum', 'taskType', 'Sex', 'paradigm', 'participantNum')] # Clean dataframe to check with Jens
dataModel = allData # Ensure correct data is taken
rm(d0.1, d0.2, d0.3) # Just to be sure you're not comparing former models for this comparison
d0.1 <- lmer(formula,data=dataModel)
d0.2 <- glmer(formula,data=dataModel, family = Gamma(link = "identity"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ = nAGQ)
d0.3 <- glmer(formula,data=dataModel, family = inverse.gaussian(link = "identity"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ = nAGQ)
# Model Selection
modelNames = c(d0.1,d0.2,d0.3)
tabel <- cbind(AIC(d0.1), AIC(d0.2), AIC(d0.3))
chosenModel = modelNames[which(tabel == min(tabel))] # Get model with lowest AIC
Anova(chosenModel[[1]], type = 'III')
plot(effect("fileNum:taskType", chosenModel[[1]]))
emmeans0.1 <- emmeans(chosenModel[[1]], pairwise ~ fileNum | taskType, adjust ="fdr", type = "response") #we don't adjust because we do this later
emmeans0.2 <- emmeans(chosenModel[[1]], pairwise ~ taskType | fileNum, adjust ="fdr", type = "response") #we don't adjust because we do this later
emm0.1 <- summary(emmeans0.1)$emmeans
emmeans0.1$contrasts
emm0.1
emmeans0.1
emmeans0.1$emmeans
summary(emmeans0.1)$emmeans
figure = behaviorplot(emm0.1, fileNum, taskType, "F0 (Pitch)") # Create plot
figure
figure = addpvalues(figure, emmeans0.1)
figure
figure = addpvaluesBetween(figure, emmeans0.2)
figure
